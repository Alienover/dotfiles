#!/usr/bin/env bash

# tmux-switchy - Fuzzy-find and switch between tmux sessions
#
# Allows quick switching to tmux sessions using fzf for interactive selection
# or direct query matching. Supports configurable session name mappings and
# automatically creates sessions if they don't exist.
#
# Usage: tmux-switchy [query]
#   Without args: Opens fzf to interactively select a session
#   With query:   Switches to session matching the query

# Define session mappings: key (for fuzzy search) -> session name (actual tmux session)
declare -A SESSION_MAPPINGS=(
  ["term"]="ðŸ¦„ term"
  ["obsidian"]="ðŸ“š Obsidian"
  ["vpn"]="ðŸŒˆ vpn"
  # Add more mappings as needed
)

# Load additional mappings from optional config file: ~/.tmux_session
# File format (one mapping per line):
#   key=session_name
# Example:
#   dotfiles=dotfiles
#   work=work-project
#   personal=personal-dev
#   # Comments start with #
load_session_mappings() {
  SESSION_CONFIG="$HOME/.tmux_session"
  if [ -f "$SESSION_CONFIG" ]; then
    while IFS='=' read -r key value; do
      # Skip empty lines and comments
      [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
      # Trim whitespace
      key=$(echo "$key" | xargs)
      value=$(echo "$value" | xargs)
      # Add to mappings if both key and value are present
      if [ -n "$key" ] && [ -n "$value" ]; then
        SESSION_MAPPINGS["$key"]="$value"
      fi
    done < "$SESSION_CONFIG"
  fi
}

# Resolve session name from query or interactive fzf selection
resolve_session() {
  local selected_session=""
  local query="$1"

  if [ -z "$1" ]; then
    C_FG=$GUI_FOREGROUND
    C_BG=$GUI_BACKGROUND
    C_PRIMARY=$GUI_PRIMARY
    C_YELLOW=$GUI_DARK_YELLOW
    C_BLACK=$GUI_BLACK

    # Refer to https://github.com/junegunn/fzf/wiki/Color-schemes#color-configuration for more detail
    FZF_OPTIONS="
      --no-info
      --no-scrollbar
      --height=100%
      --print-query
      --style=full
      --layout=reverse
      --preview-window=down
      --color fg:$C_FG,bg:$C_BG,hl:$C_PRIMARY
      --color fg+:$C_FG,bg+:$C_BLACK,hl+:$C_YELLOW
      --color gutter:$C_BG,info:$C_PRIMARY,prompt:$C_PRIMARY
      --color spinner:$C_PRIMARY,pointer:$C_BLACK,marker:$C_YELLOW,border:$C_BLACK
    "

    # Generate list of all existing sessions (excluding popup)
    SESSION_LIST=$(tmux list-sessions -F '#S' 2>/dev/null | grep -v "popup" | sort)

    query=$(echo "$SESSION_LIST" | fzf $FZF_OPTIONS --prompt "Session: "\
      --bind "ctrl-x:execute(tmux kill-session -t {} 2>/dev/null)+reload(tmux list-sessions -F '#S' 2>/dev/null | grep -v popup | sort)" \
      --preview "tmux-preview {}" \
    )
  fi

  [ -z "$query" ] && exit 0

  # When fzf is called with --print-query, it outputs 2 lines on selection:
  #   Line 1: The user's search query
  #   Line 2: The selected item
  # If we got 2 lines, extract the selected item (line 2) and return it
  if [ "$(echo "$query" | wc -l )" -eq 2 ]; then
    echo "$query" | tail -n 1
    exit 0
  fi

  load_session_mappings

  selected_session="${SESSION_MAPPINGS[$query]}"

  if [ -z "$selected_session" ]; then
    all_keys=""
    for key in "${!SESSION_MAPPINGS[@]}"; do
      all_keys="${all_keys}${key}\n"
    done
    query="$(echo -e "$all_keys" | sed '/^$/d' | fzf --filter="$query" | head -n 1)"

    [ -n "$query" ] && selected_session="${SESSION_MAPPINGS[$query]}"
  fi

  echo "$selected_session"
}


# Switches to specified tmux session, or creates it if it doesn't exist
switch_to_session() {
  local session="$1"
  if [ -n "$session" ]; then
    # Check if we're inside tmux
    if [ -n "$TMUX" ]; then
      # Inside tmux: switch to session (create if doesn't exist)
      if ! tmux has-session -t "$session" 2>/dev/null; then
        tmux new-session -d -s "$session"
      fi
      tmux switch-client -t "$session"
    else
      # Outside tmux: attach or create new session
      tmux new-session -As "$session"
    fi
  else
    echo "No project selected!"
  fi
}

switch_to_session "$(resolve_session "$1")"
